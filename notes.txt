22/Nov/2016

  - Create react app tool

    Create React App is a new officially supported way to create single-page React applications. It offers a modern build setup with no configuration.

    Create React App uses both Webpack and Babel under the hood.
    
    The console output is tuned to be minimal to help you focus on the problems.

    ESLint is also integrated so lint warnings are displayed right in the console.

    ref: https://facebook.github.io/react/blog/2016/07/22/create-apps-with-no-configuration.html

    ref: https://github.com/facebookincubator/create-react-app#getting-started


  - Webpack

    Concepts
    Webpack is a module bundler for modern JavaScript applications. It is incredibly configurable, however, there are Four Core Concepts we feel you should understand before you get started!

    Entry
    Webpack creates a graph of all of your application's dependencies. The starting point of this graph is known as an entry point. The entry point tells webpack where to start and follows the graph of dependencies to know what to bundle. You can think of your application's entry point as the contextual root or the first file to kick off your app.

    In webpack we define entry points using the entry property in our webpack configuration object.

    module.exports = {
      entry: [
        'webpack-dev-server/client?http://localhost:8080',
        'webpack/hot/only-dev-server',
        './src/index.js'
      ],

    Output
    Once you've bundled all of your assets together, we still need to tell webpack where to bundle our application. The webpack output property describes to webpack how to treat bundled code.

    output: {
      path: __dirname + '/dist',
      publicPath: '/',
      filename: 'bundle.js'
    },

    In the example above, through the output.filename and output.path properties we are describing to webpack the name of our bundle, and where we want it to be emitted to.

    Loaders
    The goal is to have all of the assets in your project to be webpack's concern and not the browser's. (This doesn't mean that they all have to be bundled together). webpack treats every file (.css, .html, .scss, .jpg, etc.) as a module. However, webpack only understands JavaScript.

    Loaders in webpack transform these files into modules as they are added to your dependency graph.

    At a high level, they have two purposes in your webpack config.

    1. Identify what files should be transformed by a certain loader. (test property)
    
    2. Transform that file so that it can be added to your dependency graph (and eventually your bundle). (use property)

    Plugins
    Since Loaders only execute transforms on a per-file basis, plugins are most commonly used (but not limited to) performing actions and custom functionality on "compilations" or "chunks" of your bundled modules (and so much more). The webpack Plugin system is extremely powerful and customizable.

    In order to use a plugin, you just need to require() it and add it to the plugins array. Most plugins are customizable via options. Since you can use a plugin multiple times in a config for different purposes, you need to create an instance of it by calling it with new.

    var webpack = require('webpack');
    ...
    plugins: [
     new webpack.HotModuleReplacementPlugin()
    ]

    ref: http://webpack.github.io/
    ref: https://webpack.js.org/concepts/


  - NPM install packages globally?

    There are two ways to install npm packages: locally or globally. You choose which kind of installation to use based on how you want to use the package.

    If you want to use it as a command line tool, something like the grunt CLI, then you want to install it globally. On the other hand, if you want to depend on the package from your own module using something like Node's require, then you want to install locally.

    ref: http://devdocs.io/npm/getting-started/installing-npm-packages-globally


  - JSX syntax

    JSX is a XML-like syntax extension to ECMAScript without any defined semantics. It's NOT intended to be implemented by engines or browsers. It's NOT a proposal to incorporate JSX into the ECMAScript spec itself. It's intended to be used by various preprocessors (transpilers) to transform these tokens into standard ECMAScript.

    This specification does not attempt to comply with any XML or HTML specification. JSX is designed as an ECMAScript feature and the similarity to XML is only for familiarity.

    ref: https://facebook.github.io/jsx/


  - Babel

    Babel has support for the latest version of JavaScript through syntax transformers. These plugins allow you to use new syntax, right now without waiting for browser support. Check out our Latest preset to get started.

    ref: https://babeljs.io/


24/Nov/2016

  - npm install --save-dev

    Installs a package.
    -D, --save-dev: Package will appear in your devDependencies.

    ref: http://devdocs.io/npm/cli/install


  - Testing react on Jsdom

    React allows you to create components that will render UI for your application. If your UI is of any complexity, you’ll likely want to test that it functions correctly and allows for future refactors. There are numerous ways to do this. One way that you might appreciate is using jsdom, an in-JavaScript implementation of the DOM.

    What is jsdom?

    Jsdom is an in-JavaScript implementation of the DOM. The DOM is the document object model, which is the tree of nodes that make up the UI for documents shown in web browsers.

    Because jsdom is implemented in JavaScript, we can have a DOM-like API to work with without needing a browser. That means that we don’t have to capture a browser in order test, a la Karma. That means that we can run our tests in environments without browsers, like in Node or in continuous integration environments.

    By not using real browsers, we’re also essentially saying that we believe the problems in our client JavaScript will not be browser-dependent (again, because we’re not capturing real browsers).

    ref: http://jaketrent.com/post/testing-react-with-jsdom/
    ref: https://github.com/tmpvar/jsdom


  - Karma

    The main goal for Karma is to bring a productive testing environment to developers. The environment being one where they don't have to set up loads of configurations, but rather a place where developers can just write the code and get instant feedback from their tests. Because getting quick feedback is what makes you productive and creative.

    ref: http://karma-runner.github.io/0.13/index.html
    
    Karma is essentially a tool which spawns a web server that executes source code against test code for each of the browsers connected. The results for each test against each browser are examined and displayed via the command line to the developer such that they can see which browsers and tests passed or failed.
    A browser can be captured either
    manually, by visiting the URL where the Karma server is listening (typically http://localhost:9876/),
    or automatically by letting Karma know which browsers to start when Karma is run (see browsers).

    ref: http://karma-runner.github.io/0.13/intro/how-it-works.html


  - Global object
    
    global#

    Added in: v0.1.27
    <Object> The global namespace object.
    In browsers, the top-level scope is the global scope. That means that in browsers if you're in the global scope var something will define a global variable. In Node.js this is different. The top-level scope is not the global scope; var something inside an Node.js module will be local to that module.

    ref: https://nodejs.org/api/globals.html#globals_global


  - glob

    Glob Primer

    "Globs" are the patterns you type when you do stuff like ls *.js on the command line, or put build/* in a .gitignore file.

    Before parsing the path part patterns, braced sections are expanded into a set. Braced sections start with { and end with }, with any number of comma-delimited sections within. Braced sections may contain slash characters, so a{/b/c,bcd} would expand into a/b/c and abcd.
    
    ref: https://github.com/isaacs/node-glob

  - npm run test -- --watch

    Run arbitrary package scripts.

    npm run-script <command> [-- <args>... ]
    alias: npm run

    Description

    This runs an arbitrary command from a package's "scripts" object. If no "command" is provided, it will list the available scripts. run[-script] is used by the test, start, restart, and stop commands, but can be called directly, as well. When the scripts in the package are printed out, they're separated into lifecycle (test, start, restart) and directly-run scripts.

    As of npm@2.0.0, you can use custom arguments when executing scripts. The special option -- is used by getopt to delimit the end of the options. npm will pass all the arguments after the -- directly to your script:

    npm run test -- --grep="pattern"
    The arguments will only be passed to the script specified after npm run and not to any pre or post script.

    The env script is a special built-in command that can be used to list environment variables that will be available to the script at runtime. If an "env" command is defined in your package it will take precedence over the built-in.

    In addition to the shell's pre-existing PATH, npm run adds node_modules/.bin to the PATH provided to scripts. Any binaries provided by locally-installed dependencies can be used without the node_modules/.bin prefix. For example, if there is a devDependency on tap in your package, you should write:

    "scripts": {"test": "tap test/\*.js"}
    instead of "scripts": {"test": "node_modules/.bin/tap test/\*.js"} to run your tests.

    If you try to run a script without having a node_modules directory and it fails, you will be given a warning to run npm install, just in case you've forgotten.

    ref: http://devdocs.io/npm/cli/run-script

    Test a package.

      npm test [-- <args>]
      npm tst [-- <args>]

    This runs a package's "test" script, if one was provided.

    To run tests as a condition of installation, set the npat config to true.

    ref: http://devdocs.io/npm/cli/test


  - "Pure components"

    1. A pure component receives all its data as props, like a function receives all its data as arguments. It should have no side effects, including reading data from anywhere else, initiating network requests, etc.

    2. A pure component generally has no internal state. What it renders is fully driven by its input props. Rendering the same pure component twice with the same props should result in the same UI. There's no hidden state inside the component that would cause the UI to differ between the two renders.

    ref: https://www.youtube.com/watch?v=1uRC3hmKQnM&feature=youtu.be&t=13m10s

  - What is react-hot-loader?

    Introduction

    Hot Module Replacement (HMR) exchanges, adds, or removes modules while an application is running without a page reload.

    How does it work?

    Webpacks adds a small HMR runtime to the bundle, during the build process, that runs inside your app. When the build completes, Webpack does not exit but stays active, watching the source files for changes. If Webpack detects a source file change, it rebuilds only the changed module(s). Depending on the settings, Webpack will either send a signal to the HMR runtime, or the HMR runtime will poll webpack for changes. Either way, the changed module is sent to the HMR runtime which then tries to apply the hot update. First it checks whether the updated module can self-accept. If not, it checks those modules that have required the updated module. If these too do not accept the update, it bubbles up another level, to the modules that required the modules that required the changed module. This bubbling-up will continue until either the update is accepted, or the app entry point is reached, in which case the hot update fails.

    ref: https://www.youtube.com/watch?v=1uRC3hmKQnM&feature=youtu.be&t=13m10s
    ref: https://www.youtube.com/watch?v=xsSnOQynTHs


  - react-hot vs react-hot-loader/webpack

    $ webpack-dev-server
    
    ERROR MESSAGE:

    ERROR in ./src/index.js
    
    Module build failed: Error: React Hot Loader: The Webpack loader is now exported separately. If you use Babel, we recommend that you remove "react-hot-loader" from the "loaders" section of your Webpack configuration altogether, and instead add "react-hot-loader/babel" to the "plugins" section of your .babelrc file. If you prefer not to use Babel, replace "react-hot-loader" or "react-hot" with "react-hot-loader/webpack" in the "loaders" section of your Webpack configuration.
    at Object.warnAboutIncorrectUsage (/home/daniel/github/voting-client-screencast/node_modules/react-hot-loader/lib/index.js:7:11)
    @ multi main
    webpack: bundle is now VALID.

    ref: https://teamtreehouse.com/community/anyone-else-getting-an-error-when-including-react-hot-loader-in-the-webpack-config
    ref: https://github.com/maxfarseer/redux-ru-tutorial/issues/2


25/Nov/2016

  - Feedback loop
    
    ref: http://www.bbc.com/news/world-us-canada-38083733

  - CJSX Syntax highlighting

  - JSX Linter

  - renderIntoDocument
    ref: https://facebook.github.io/react/docs/test-utils.html#renderintodocument

  - scry...
    ref: https://facebook.github.io/react/docs/test-utils.html#scryrendereddomcomponentswithtag

  - simulate
    ref: https://facebook.github.io/react/docs/test-utils.html#simulate

  - ...this.props

  - ref
    ref: https://facebook.github.io/react/docs/refs-and-the-dom.html